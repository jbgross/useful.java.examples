package com.joshuabgross.cs.examples.binary;

import java.io.*;

/**
 * This class demonstrates the bitwise operators in Java (although they are
 * common to C-like languages) by performing operations on one or a pair of
 * bytes. Instances read through an array of bytes, either randomly generated or 
 * passed in via the constructor
 * @author joshua.gross
 */
public class BitShifting {

    private byte [] data;

    /**
     * The default number of bytes to create and convert; has to be static to
     * use in argument passed to secondary constructor
     */
    public static final int DEFAULTCOUNT = 8;
    
    /**
     * With no argument, randomly generates DEFAULTCOUNT number of bytes 
     * and loops through them
     */
    public BitShifting() {
        this(BitShifting.DEFAULTCOUNT);
    }
    
    /**
     * With no argument, randomly generates DEFAULTCOUNT number of bytes 
     * and loops through them
     * @param count the number of bytes to generate (will perform 1/2
     * that number of comparisons)
     */
    public BitShifting(int count) {
        this.data = BinaryData.generateRandomBytes(count);
        this.run();
    }
    
    /**
     * 
     * @param data an array of bytes from another source (e.g., read in from
     * BinaryData)
     */
    public BitShifting(byte [] data) {
        this.data = data;
        this.run();
    }
    
    /**
     * This final constructor takes the name of a binary file. This file could
     * have been generated by the BinaryData class, but it should work for
     * any binary file. The filename must be absolute, or it will attempt to 
     * open the file from where it is run (the root of the project by default in
     * most IDEs).
     * @param filename the name of the binary file to open
     * @throws IOException thrown if something bad happens, like the file cannot
     * be opened, perhaps because it doesn't exist
     */
    public BitShifting(String filename) throws IOException {
        this(BinaryData.read(filename));
    }
    /**
     * No need to make this threaded right now, but easily done and
     * use of StringBuilder will prevent conflicts
     */
    private void run () {
        // loop through each pair
        for (int i = 0; i < this.data.length - 1; i += 2) {
            BitShifting.BytePair bp = new BitShifting.BytePair(this.data[i], this.data[i + 1]);
            System.out.println(bp.convert());
        }
    }

    /**
     * Internal class to hold a pair of bytes and do a series of bitwise 
     * conversions using one or both, returning the results as a string
     */
    class BytePair {

        byte a;
        byte b;

        BytePair(Byte a, Byte b) {
            this.a = a;
            this.b = b;
        }

        private String byteToBinary(byte c) {
            return String.format("%8s", Integer.toBinaryString(c & 0xFF)).replace(' ', '0');
        }

        @Override
        public String toString() {
            return this.byteToBinary(a) + " (" + a + "): a\n"
                    + this.byteToBinary(b) + " (" + b + "): b";
        }

        public String convert() {
            StringBuilder build = new StringBuilder();
            byte and = (byte) (a & b);
            byte or = (byte) (a | b);
            byte xor = (byte) (a ^ b);
            byte acomp = (byte) ~a;
            byte left4 = (byte) (a << 4);
            byte right4 = (byte) (a >> 4);
            byte logicalRight4 = (byte) (a >>> 4);

            build.append(this);
            build.append(this.byteToBinary(and)).append(" (").append(and).append("): ").append(a).append(" & ").append(b);
            build.append("\n");
            build.append(this.byteToBinary(or)).append(" (").append(or).append("): ").append(a).append(" | ").append(b);
            build.append("\n");
            build.append(this.byteToBinary(xor)).append(" (").append(xor).append("): ").append(a).append(" ^ ").append(b);
            build.append("\n");
            build.append(this.byteToBinary(acomp)).append(" (").append(acomp).append("): ^").append(a);
            build.append("\n");
            build.append(this.byteToBinary(left4)).append(" (").append(left4).append("): ").append(a).append("<<4");
            build.append("\n");
            build.append(this.byteToBinary(right4)).append(" (").append(right4).append("): ").append(a).append(">>4");
            build.append("\n");
            build.append(this.byteToBinary(logicalRight4)).append(" (").append(logicalRight4).append("): ").append(a).append(">>>4 (zero not preserved)");
            build.append("\n");
            build.append(this.eachBit(a)).append(": each byte of ").append(a);
            build.append("\n");
            build.append(a).append(" is").append(this.isPositive(a) ? " not" : "").append(" negative based on the first bit");

            //this.eachBit(a)).append(": each byte of ").append(a);
            build.append("\n");
            return build.toString();
        }

        String eachBit(byte c) {
            StringBuilder buildf = new StringBuilder();
            for (int i = 7; i >= 0; i--) {
                buildf.append(c >> i & 1);
            }
            return buildf.toString();
        }

        boolean isPositive(byte c) {
            return (c >> 7 == 0);
        }
    }
}
